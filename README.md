# 函数依赖挖掘实验报告

贾元昊 软件51 2015013193 

李金明 软件51 2015013208

### 实验环境

>OS: Windows 10
>
>IDE: Visual Studio 2017 (Visual C++ 2017)
>
>CPU: Intel Core i7-4720HQ, i7-7500U
>
>RAM: 8G

### 编程语言

使用C++，使用C++ 11/14部分特性

### 实验过程

1. 由于课上对tane的思想讲的比较详细，理解起来比较容易，再加上实现简单，因此在所有算法中决定实现TANE算法。
2. 读PPT和论文。
3. 代码完成。
   1. 首先实现了文件的读入部分，能将读入的每一行通过 “,” 来划分并储存在string数组中。
   2. 主要算法部分实现参照论文《Tane: An Efficient Algorithm for Discovering Functional and Approximate Dependencies》第四节中的伪代码
   3. 为了提高代码的性能且测试数据只有15个属性，这里将关系的属性集合考虑成一个整数的形式，其二进制上的第i位代表是否包含第i个属性。这样的实现使得集合间的运算变得非常方便。
   4. 而对于等价类π,因为涉及到的row会高达9万,因此将其处理成vector中的vector。
   5. 其中伪代码中有部分说明不清的，参考了第三节中的各种定理。例如对ε的选择上，如果不选择为0则会影响最后结果的正确性（否则算的近似函数依赖）。在伪代码的prune函数中如果X是(super)Key将会从L中将其删除，这样会导致之后将不会计算包含X的属性集的C+，而这些C+可能会被调用，从而影响结果的正确性，因此会先判断并用递归算出其值
   6. 最后将tane的整个算法过程封装到了一个TANE类中。
4. 测试小数据，通过。
5. 测试大数据，对拍结果。
6. 优化性能。
   1. 大量剪枝算法：
      首先是算法中本身的优化，包括判断X\\{A}->A中用不等式的性质，删除当前层的属性集等
       其次就是将关系的属性集合考虑成一个整数的形式，通过位运算的方式减少复杂度。而在这之前已经通过vector记录了当前整数中包含了那些属性，使用时直接枚举即可。
       最后是通过设置标记数组，来记录一些状态，例如记录当前属性集是否某层中而不必遍历，当前使用的C+是否是计算过的等。

   2. 尝试使用多线程，有一点点优化，但是由于线程间的冲突导致并行度不高，不冲突的话开内存开销大，所以最后多线程优化的效果不是很理想。

      *最新更新：尝试利用大量的共享空间换取时间，最后的多线程效果还是有一定效果的。*
### 实验结果分析

- 结果：518行函数依赖，对拍后结果正确。
- 运行时间：
  - 无优化，200+s，内存占用1.8GB
  - -O2优化，1.7s左右，内存占用584MB
  - 时间占用最主要的部分就是GenerateNextLevel，其中最占用的部分是计算partition product。